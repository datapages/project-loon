[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Project Loon",
    "section": "",
    "text": "Welcome to the datapage for Project Loon data! For more details on the dataset, please see the About tab. On this page, we offer several tools to select and visualize data from individual balloons. The raw data can be viewed and downloaded from the Data tab, and the Analysis tab offers other data access and analysis tools. We’re currently working on more tools to visualize and access the data, so stay tuned!\nIn this dataset, there are 385 balloon flights, split into 938 data segments. The figure on the right shows the number of unique flights that passed through each 5 degree latitude by 10 degree longitude grid cell.\n\n    \n    \n  \n\n\n\n\nimport {interval} from '@mootari/range-slider' // two ended slider\ninterval_format = ([start, end]) =&gt; `[${start}, ${end}]`\n\nseasons = [\"spring\", \"summer\", \"fall\", \"winter\"]\n\n// all segments\ns = transpose(segments)\n\n// all segments' data\nd = transpose(data).map(d =&gt; ({ ...d, time: new Date(d.time) }))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nns = Inputs.text().classList[0]\n\n// custom css to override some ojs defaults for inputs\nhtml`&lt;style&gt;\n\n  .${ns} {\n    --label-width: 70px;\n  }\n\n  .${ns} div label {\n    background-color: #f4f4f4;\n    padding: 0.25rem 0.5rem;\n    border-radius: 0.5rem;\n    margin-right: 0.25rem;\n    width: auto;\n  }\n  \n  .${ns} div label:hover,\n  .${ns} div label:active,\n  .${ns} div label:focus {\n    background-color: #cdecff;\n  }\n  \n  .${ns} div input[type=\"number\"] {\n    background-color: #f4f4f4;\n    padding: 0.25rem 0.5rem;\n    border-radius: 0.5rem;\n    flex-shrink: 3;\n    border: none;\n  }\n  \n  .${ns} select {\n    background-color: #f4f4f4;\n    border: none;\n    border-radius: 0.5rem;\n    padding: 0.25rem 0.5rem;\n    width: auto;\n  }\n}\n&lt;/style&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUse these filters to narrow down the list of segments, and then select an individual segment from this list below to visualize its trajectory and telemetry.\n\n\n// filter by season(s)\nviewof season = Inputs.checkbox(seasons, {value: seasons, label: \"Season (astronomical)\"})\n\n\n\n\n\n\n\n// filter by range of longitudes\nviewof longitude_range = interval([-180, 180], {\n  step: 1, label: \"Longitudes\", width: \"80%\", format: interval_format\n})\n\n\n\n\n\n\n\n// filter by range of latitudes\nviewof latitude_range = interval([-90, 90], {\n  step: 1, label: \"Latitudes\", width: \"80%\", format: interval_format\n})\n\n\n\n\n\n\n\n// filter by range of durations\nviewof duration_range = interval([0, 100], {\n  step: 1, label: \"Duration (days)\", width: \"80%\", format: interval_format\n})\n\n\n\n\n\n\n\n\nsf = s.filter(d =&gt; season.some(se =&gt; d.season.includes(se)))\n      .filter(d =&gt; d.longitude_min &lt;= longitude_range[1] &\n                   d.longitude_max &gt;= longitude_range[0])\n      .filter(d =&gt; d.latitude_min &lt;= latitude_range[1] &\n                   d.latitude_max &gt;= latitude_range[0])\n      .filter(d =&gt; d.duration &gt;= duration_range[0] &\n                   d.duration &lt;= duration_range[1])\n\n// filtered segments' IDs\nsf_id = sf.map(d =&gt; d.segment_id)\n\n// filtered segments' data\ndf = d.filter(d =&gt; sf_id.includes(d.segment_id))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nland = FileAttachment(\"topo/ne_110m_land.json\").json()\nocean = FileAttachment(\"topo/ne_110m_ocean.json\").json()\n\nland_color = \"wheat\"\nocean_color = \"#8398aa\"\n\n// map -- globe\nviewof map_globe = Plot.plot({\n  width: 400,\n  projection: {type: \"orthographic\", rotate: [-longitude, -latitude]},\n  marks: [\n    Plot.sphere(),\n    Plot.graticule(),\n    Plot.geo(ocean, {fill: ocean_color, opacity: 0.7}),\n    Plot.geo(land, {fill: land_color}),\n    Plot.line(df, {\n      x: \"longitude\", y: \"latitude\", z: \"segment_id\",\n      r: 0.8, stroke: \"grey\", strokeOpacity: 0.8,\n    }),\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof longitude = Inputs.range([-180, 180], {label: \"Longitude\", step: 1, value: -30})\nviewof latitude = Inputs.range([-90, 90], {label: \"Latitude\", step: 1, value: 0})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndg = d3.group(df, d =&gt; d.segment_id)\n\nviewof ds = Inputs.select(dg, {\n  value: dg.get(112),\n  format: ([k, v]) =&gt; `Segment ${k} (Flight ${v[0].flight_id})`\n})\nviewof map_world = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  projection: { type: \"equirectangular\" },\n  marks: [\n    //Plot.sphere(),\n    Plot.frame(),\n    Plot.graticule(),\n    Plot.geo(land, {fill: \"lightgrey\"}),\n    Plot.line(ds, {\n      x: \"longitude\", y: \"latitude\",\n      r: 1, stroke: \"black\", strokeOpacity: 0.2,\n    }),\n    Plot.dot(ds.slice(0, 1), {\n      x: \"longitude\", y: \"latitude\",\n      r: 3, stroke: \"red\", strokeOpacity: 1, symbol: \"plus\"\n    }),\n    Plot.dot(ds.slice(ds.length - 1, ds.length), {\n      x: \"longitude\", y: \"latitude\",\n      r: 3, stroke: \"red\", strokeOpacity: 1, symbol: \"times\"\n    })\n  ],\n})\n\n// find minimal radius circle that includes entire flight path\nminLon = d3.min(ds.map(d =&gt; d.longitude))\nmaxLon = d3.max(ds.map(d =&gt; d.longitude))\nminLat = d3.min(ds.map(d =&gt; d.latitude))\nmaxLat = d3.max(ds.map(d =&gt; d.latitude))\ncenter = [(minLon + maxLon) / 2, (minLat + maxLat) / 2]\ncorners = [[minLon, minLat], [minLon, maxLat], [maxLon, minLat], [maxLon, maxLat]]\ndist = d3.max(corners, corner =&gt; d3.geoDistance(center, corner))\nradius = dist * (180 / Math.PI)\ncircle = d3.geoCircle().center(center).radius(radius)()\n\n// map -- zoomed in azimuthal\nviewof map_zoom = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  projection: { type: \"azimuthal-equidistant\", domain: circle },\n  marks: [\n    Plot.frame(),\n    Plot.graticule(),\n    Plot.geo(land, {fill: \"lightgrey\"}),\n    Plot.line(ds, {\n      x: \"longitude\", y: \"latitude\",\n      r: 1, stroke: \"black\", strokeOpacity: 0.2,\n    }),\n    Plot.dot(ds.slice(0, 1), {\n      x: \"longitude\", y: \"latitude\",\n      r: 6, stroke: \"red\", strokeOpacity: 1, symbol: \"plus\"\n    }),\n    Plot.dot(ds.slice(ds.length - 1, ds.length), {\n      x: \"longitude\", y: \"latitude\",\n      r: 6, stroke: \"red\", strokeOpacity: 1, symbol: \"times\"\n    })\n  ],\n})\nviewof scatter_alt = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  width: 900,\n  height: 200,\n  inset: 8,\n  grid: true,\n  y: { label: \"Altitude (meters)\" },\n  marks: [\n    Plot.dot(ds, { x: \"time\", y: \"altitude\", r: 0.5 }),\n  ]\n})\n\n// timeseries -- winds\nwinds = new Map([[\"Zonal (east-west)\", \"wind_u\"],\n                 [\"Meridional (north-south)\", \"wind_v\"]])\nviewof y_wind = Inputs.select(winds, {label: \"Wind\"})\n\nviewof scatter_wind = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  width: 900,\n  height: 200,\n  inset: 8,\n  grid: true,\n  y: { label: \"Velocity (meters/second)\" },\n  marks: [\n    Plot.dot(ds, { x: \"time\", y: y_wind, r: 0.5 }),\n  ]\n})\n\n// timeseries -- fluxes\nfluxes = new Map([[\"Eastward\", \"flux_east\"], [\"Westward\", \"flux_west\"],\n                  [\"Northward\", \"flux_north\"], [\"Southward\", \"flux_south\"]])\nviewof y_flux = Inputs.select(fluxes, {label: \"Flux\"})\n\nviewof scatter_flux = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  width: 900,\n  height: 200,\n  inset: 8,\n  grid: true,\n  y: { label: \"Flux (millipascals)\", transform: (f) =&gt; Math.abs(f * 1000) },\n  marks: [\n    Plot.dot(ds, { x: \"time\", y: y_flux, r: 0.5 }),\n  ]\n})"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Project Loon",
    "section": "",
    "text": "The purpose of this dataset is to offer an estimate of the horizontal momentum fluxed vertically by the atmospheric internal gravity waves (GWs) observed by Project Loon balloons. This vertical flux of horizontal momentum is commonly referred to as the GW momentum flux. Before estimating the GW momentum fluxes, additional processing was necessary to remove data sampling errors, irregularities, and balloon maneuvering.\n\n\n\nThe procedures for this processing, and the subsequent analysis of the processed data, are described in Green et al. (2024). The Python code (in Jupyter notebooks) that was used for both is available at: https://github.com/DataWaveProject/Loon-momentum-fluxes.\n\n\n\nSee the following sample project for examples: https://redivis.com/projects/q08b-889vc3xgg."
  },
  {
    "objectID": "about.html#project-loon",
    "href": "about.html#project-loon",
    "title": "Project Loon",
    "section": "",
    "text": "The purpose of this dataset is to offer an estimate of the horizontal momentum fluxed vertically by the atmospheric internal gravity waves (GWs) observed by Project Loon balloons. This vertical flux of horizontal momentum is commonly referred to as the GW momentum flux. Before estimating the GW momentum fluxes, additional processing was necessary to remove data sampling errors, irregularities, and balloon maneuvering.\n\n\n\nThe procedures for this processing, and the subsequent analysis of the processed data, are described in Green et al. (2024). The Python code (in Jupyter notebooks) that was used for both is available at: https://github.com/DataWaveProject/Loon-momentum-fluxes.\n\n\n\nSee the following sample project for examples: https://redivis.com/projects/q08b-889vc3xgg."
  },
  {
    "objectID": "analysis.html",
    "href": "analysis.html",
    "title": "Project Loon",
    "section": "",
    "text": "You can access the project_loon data programmatically using the Redivis API for R or Python.\n\nRPython\n\n\n\nInstall the redivis-r package:\n\ndevtools::install_github(\"redivis/redivis-r\")\n\nGenerate and set an API token.\nAccess the data:\n\nlibrary(redivis)\n\nuser &lt;- redivis::user(\"sdss\")\ndataset &lt;- user$dataset(\"project_loon\")\ntable &lt;- dataset$table(\"loon\")\n\n# Load table as tidyverse tibble\ndf &lt;- table$to_tibble()\nView documentation\n\n\n\nInstall the redivis-python client library:\n\npip install --upgrade redivis\n\nGenerate and set an API token.\nAccess the data:\n\nimport redivis\n\nuser = redivis.user(\"sdss\")\ndataset = user.dataset(\"project_loon\")\ntable = dataset.table(\"loon\")\n\n# Load table as a dataframe\ndf = table.to_pandas_dataframe()\nView documentation"
  },
  {
    "objectID": "analysis.html#programmatic-access",
    "href": "analysis.html#programmatic-access",
    "title": "Project Loon",
    "section": "",
    "text": "You can access the project_loon data programmatically using the Redivis API for R or Python.\n\nRPython\n\n\n\nInstall the redivis-r package:\n\ndevtools::install_github(\"redivis/redivis-r\")\n\nGenerate and set an API token.\nAccess the data:\n\nlibrary(redivis)\n\nuser &lt;- redivis::user(\"sdss\")\ndataset &lt;- user$dataset(\"project_loon\")\ntable &lt;- dataset$table(\"loon\")\n\n# Load table as tidyverse tibble\ndf &lt;- table$to_tibble()\nView documentation\n\n\n\nInstall the redivis-python client library:\n\npip install --upgrade redivis\n\nGenerate and set an API token.\nAccess the data:\n\nimport redivis\n\nuser = redivis.user(\"sdss\")\ndataset = user.dataset(\"project_loon\")\ntable = dataset.table(\"loon\")\n\n# Load table as a dataframe\ndf = table.to_pandas_dataframe()\nView documentation"
  }
]