[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Project Loon",
    "section": "",
    "text": "The purpose of this dataset is to offer an estimate of the vertical flux of horizontal momentum by the atmospheric internal gravity waves (GWs) observed by Project Loon balloons. These waves are commonly too small in scale to be resolved in models of the atmosphere, and yet they play an important role in the atmosphere’s circulation and variability. Their momentum flux, converted to a drag on the background wind when they dissipate, is one aspect of their influence. To better understand the waves and their forcing on the atmosphere, and to provide observational constraints for parameterizations that mimic their effects in models, Green et al. (2024, cited below) estimated the GW momentum flux from Project Loon data.\n\n\n\nBefore estimating the momentum fluxes, additional processing was necessary to remove data sampling errors, irregularities, and balloon maneuvering. The balloons’ time series data were analyzed using a Morlet continuous wavelet transform, and the momentum flux time series are the wavelet cross-spectra integrated over the GW frequency range. For more details on the data processing, wavelet analysis, and an analysis of the momentum fluxes, please see Green et al. (2024). The Python code (in Jupyter notebooks) that was used for all three is available at: https://github.com/DataWaveProject/Loon-momentum-fluxes. The unprocessed Loon data are available on Zenodo: https://zenodo.org/records/5119968.\n\n\n\nA workflow that loads the dataset and reproduces Figure 1 of Green et al. (2024) can be found at: https://redivis.com/projects/q08b-889vc3xgg."
  },
  {
    "objectID": "about.html#project-loon",
    "href": "about.html#project-loon",
    "title": "Project Loon",
    "section": "",
    "text": "The purpose of this dataset is to offer an estimate of the vertical flux of horizontal momentum by the atmospheric internal gravity waves (GWs) observed by Project Loon balloons. These waves are commonly too small in scale to be resolved in models of the atmosphere, and yet they play an important role in the atmosphere’s circulation and variability. Their momentum flux, converted to a drag on the background wind when they dissipate, is one aspect of their influence. To better understand the waves and their forcing on the atmosphere, and to provide observational constraints for parameterizations that mimic their effects in models, Green et al. (2024, cited below) estimated the GW momentum flux from Project Loon data.\n\n\n\nBefore estimating the momentum fluxes, additional processing was necessary to remove data sampling errors, irregularities, and balloon maneuvering. The balloons’ time series data were analyzed using a Morlet continuous wavelet transform, and the momentum flux time series are the wavelet cross-spectra integrated over the GW frequency range. For more details on the data processing, wavelet analysis, and an analysis of the momentum fluxes, please see Green et al. (2024). The Python code (in Jupyter notebooks) that was used for all three is available at: https://github.com/DataWaveProject/Loon-momentum-fluxes. The unprocessed Loon data are available on Zenodo: https://zenodo.org/records/5119968.\n\n\n\nA workflow that loads the dataset and reproduces Figure 1 of Green et al. (2024) can be found at: https://redivis.com/projects/q08b-889vc3xgg."
  },
  {
    "objectID": "analysis.html",
    "href": "analysis.html",
    "title": "Project Loon",
    "section": "",
    "text": "You can access the project_loon data programmatically using the Redivis API for R or Python.\n\nRPython\n\n\n\nInstall the redivis-r package:\n\ndevtools::install_github(\"redivis/redivis-r\")\n\nGenerate and set an API token.\nAccess the data:\n\nlibrary(redivis)\n\nuser &lt;- redivis::user(\"sdss\")\ndataset &lt;- user$dataset(\"project_loon\")\ntable &lt;- dataset$table(\"loon\")\n\n# Load table as tidyverse tibble\ndf &lt;- table$to_tibble(max_results = 100)\nView documentation\n\n\n\nInstall the redivis-python client library:\n\npip install --upgrade redivis\n\nGenerate and set an API token.\nAccess the data:\n\nimport redivis\n\nuser = redivis.user(\"sdss\")\ndataset = user.dataset(\"project_loon\")\ntable = dataset.table(\"loon\")\n\n# Load table as a dataframe\ndf = table.to_pandas_dataframe(max_results = 100)\nView documentation"
  },
  {
    "objectID": "analysis.html#programmatic-access",
    "href": "analysis.html#programmatic-access",
    "title": "Project Loon",
    "section": "",
    "text": "You can access the project_loon data programmatically using the Redivis API for R or Python.\n\nRPython\n\n\n\nInstall the redivis-r package:\n\ndevtools::install_github(\"redivis/redivis-r\")\n\nGenerate and set an API token.\nAccess the data:\n\nlibrary(redivis)\n\nuser &lt;- redivis::user(\"sdss\")\ndataset &lt;- user$dataset(\"project_loon\")\ntable &lt;- dataset$table(\"loon\")\n\n# Load table as tidyverse tibble\ndf &lt;- table$to_tibble(max_results = 100)\nView documentation\n\n\n\nInstall the redivis-python client library:\n\npip install --upgrade redivis\n\nGenerate and set an API token.\nAccess the data:\n\nimport redivis\n\nuser = redivis.user(\"sdss\")\ndataset = user.dataset(\"project_loon\")\ntable = dataset.table(\"loon\")\n\n# Load table as a dataframe\ndf = table.to_pandas_dataframe(max_results = 100)\nView documentation"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Project Loon",
    "section": "",
    "text": "Welcome to the Datapages site for Project Loon balloon data! Loon balloons were “superpressure” balloons: the pressure inside their envelopes was higher than the ambient pressure, keeping the volume of the envelope constant. When in passive flight, the balloons drifted on surfaces of constant density in the lower stratosphere. In this dataset, there are 385 balloon flights, split into 938 data segments, all at least two days long and corresponding to intervals when the balloons were passively drifting. For more details on the dataset, please see the About tab. The full dataset on Redivis can be accessed from the Data tab, and the Analysis tab offers tools to access the dataset using R or Python.\nOn this page, we offer several tools to select, visualize, and download data from individual balloons and groups of balloons. Immediately below you will find a tool that allows you to select and plot the trajectories of a subset of data segments based on the time of year the data were collected and where the balloons flew. You can download a downsampled (10x, or one data point every 20 minutes) version of the dataset that includes just the selected segments, or generate a code snippet in R or Python that loads the complete dataset for those segments. To avoid accidentally accessing unnecessarily large quantities of data, the code snippet only loads 100 rows of data by default; to load all the selected data, comment out the “LIMIT 100” line.\nBelow that we offer an additional set of plotting tools for individual data segments drawn from the subset of segments selected earlier. Time series of the balloon’s altitude, horizontal velocities, and analyzed gravity wave momentum flux are plotted from the downsampled data, which are shown in a table at the bottom. There is an option to download the segment’s complete data. After clicking the “Download segment” button and logging in to Redivis, please wait a couple seconds for the data to be prepared for download.\n\n\n\n\n\n\n\nImage from Wikipedia by Flickr user Wasting Frames, license CC BY 2.0."
  },
  {
    "objectID": "index.html#segment-selection",
    "href": "index.html#segment-selection",
    "title": "Project Loon",
    "section": "Segment selection",
    "text": "Segment selection\n\nfunction interval(range = [], options = {}) {\n  const [min = 0, max = 1] = range;\n  const {\n    step = .001,\n    label = null,\n    value = [min, max],\n    format = ([start, end]) =&gt; `${start} … ${end}`,\n    color,\n    width,\n    theme,\n    __ns__ = randomScope(),\n  } = options;\n\n  const css = `\n#${__ns__} {\n  font: 13px/1.2 var(--sans-serif);\n  display: flex;\n  align-items: baseline;\n  flex-wrap: wrap;\n  max-width: 100%;\n  width: auto;\n}\n@media only screen and (min-width: 30em) {\n  #${__ns__} {\n    flex-wrap: nowrap;\n    width: 360px;\n  }\n}\n#${__ns__} .label {\n  width: 120px;\n  padding: 5px 0 4px 0;\n  margin-right: 6.5px;\n  flex-shrink: 0;\n}\n#${__ns__} .form {\n  display: flex;\n  width: 100%;\n}\n#${__ns__} .range {\n  flex-shrink: 1;\n  width: 100%;\n}\n#${__ns__} .range-slider {\n  width: 100%;\n}\n  `;\n  \n  const $range = rangeInput({min, max, value: [value[0], value[1]], step, color, width, theme});\n  const $output = html`&lt;output&gt;`;\n  const $view = html`&lt;div id=${__ns__}&gt;\n${label == null ? '' : html`&lt;div class=\"label\"&gt;${label}`}\n&lt;div class=form&gt;\n  &lt;div class=range&gt;\n    ${$range}&lt;div class=range-output&gt;${$output}&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n${html`&lt;style&gt;${css}`}\n  `;\n\n  const update = () =&gt; {\n    const content = format([$range.value[0], $range.value[1]]);\n    if(typeof content === 'string') $output.value = content;\n    else {\n      while($output.lastChild) $output.lastChild.remove();\n      $output.appendChild(content);\n    }\n  };\n  $range.oninput = update;\n  update();\n  \n  return Object.defineProperty($view, 'value', {\n    get: () =&gt; $range.value,\n    set: ([a, b]) =&gt; {\n      $range.value = [a, b];\n      update();\n    },\n  });\n}\n\nfunction rangeInput(options = {}) {\n  const {\n    min = 0,\n    max = 100,\n    step = 'any',\n    value: defaultValue = [min, max],\n    color,\n    width,\n    theme = theme_Flat,\n  } = options;\n  \n  const controls = {};\n  const scope = randomScope();\n  const clamp = (a, b, v) =&gt; v &lt; a ? a : v &gt; b ? b : v;\n\n  // Will be used to sanitize values while avoiding floating point issues.\n  const input = html`&lt;input type=range ${{min, max, step}}&gt;`;\n  \n  const dom = html`&lt;div class=${`${scope} range-slider`} style=${{\n    color,\n    width: cssLength(width),\n  }}&gt;\n  ${controls.track = html`&lt;div class=\"range-track\"&gt;\n    ${controls.zone = html`&lt;div class=\"range-track-zone\"&gt;\n      ${controls.range = html`&lt;div class=\"range-select\" tabindex=0&gt;\n        ${controls.min = html`&lt;div class=\"thumb thumb-min\" tabindex=0&gt;`}\n        ${controls.max = html`&lt;div class=\"thumb thumb-max\" tabindex=0&gt;`}\n      `}\n    `}\n  `}\n  ${html`&lt;style&gt;${theme.replace(/:scope\\b/g, '.'+scope)}`}\n&lt;/div&gt;`;\n\n  let value = [], changed = false;\n  Object.defineProperty(dom, 'value', {\n    get: () =&gt; [...value],\n    set: ([a, b]) =&gt; {\n      value = sanitize(a, b);\n      updateRange();\n    },\n  });\n\n  const sanitize = (a, b) =&gt; {\n    a = isNaN(a) ? min : ((input.value = a), input.valueAsNumber);\n    b = isNaN(b) ? max : ((input.value = b), input.valueAsNumber);\n    return [Math.min(a, b), Math.max(a, b)];\n  }\n  \n  const updateRange = () =&gt; {\n    const ratio = v =&gt; (v - min) / (max - min);\n    dom.style.setProperty('--range-min', `${ratio(value[0]) * 100}%`);\n    dom.style.setProperty('--range-max', `${ratio(value[1]) * 100}%`);\n  };\n\n  const dispatch = name =&gt; {\n    dom.dispatchEvent(new Event(name, {bubbles: true}));\n  };\n  const setValue = (vmin, vmax) =&gt; {\n    const [pmin, pmax] = value;\n    value = sanitize(vmin, vmax);\n    updateRange();\n    // Only dispatch if values have changed.\n    if(pmin === value[0] && pmax === value[1]) return;\n    dispatch('input');\n    changed = true;\n  };\n  \n  setValue(...defaultValue);\n  \n  // Mousemove handlers.\n  const handlers = new Map([\n    [controls.min, (dt, ov) =&gt; {\n      const v = clamp(min, ov[1], ov[0] + dt * (max - min));\n      setValue(v, ov[1]);\n    }],\n    [controls.max, (dt, ov) =&gt; {\n      const v = clamp(ov[0], max, ov[1] + dt * (max - min));\n      setValue(ov[0], v);\n    }],\n    [controls.range, (dt, ov) =&gt; {\n      const d = ov[1] - ov[0];\n      const v = clamp(min, max - d, ov[0] + dt * (max - min));\n      setValue(v, v + d);\n    }],\n  ]);\n  \n  // Returns client offset object.\n  const pointer = e =&gt; e.touches ? e.touches[0] : e;\n  // Note: Chrome defaults \"passive\" for touch events to true.\n  const on  = (e, fn) =&gt; e.split(' ').map(e =&gt; document.addEventListener(e, fn, {passive: false}));\n  const off = (e, fn) =&gt; e.split(' ').map(e =&gt; document.removeEventListener(e, fn, {passive: false}));\n  \n  let initialX, initialV, target, dragging = false;\n  function handleDrag(e) {\n    // Gracefully handle exit and reentry of the viewport.\n    if(!e.buttons && !e.touches) {\n      handleDragStop();\n      return;\n    }\n    dragging = true;\n    const w = controls.zone.getBoundingClientRect().width;\n    e.preventDefault();\n    handlers.get(target)((pointer(e).clientX - initialX) / w, initialV);\n  }\n  \n  \n  function handleDragStop(e) {\n    off('mousemove touchmove', handleDrag);\n    off('mouseup touchend', handleDragStop);\n    if(changed) dispatch('change');\n  }\n  \n  invalidation.then(handleDragStop);\n  \n  dom.ontouchstart = dom.onmousedown = e =&gt; {\n    dragging = false;\n    changed = false;\n    if(!handlers.has(e.target)) return;\n    on('mousemove touchmove', handleDrag);\n    on('mouseup touchend', handleDragStop);\n    e.preventDefault();\n    e.stopPropagation();\n    \n    target = e.target;\n    initialX = pointer(e).clientX;\n    initialV = value.slice();\n  };\n  \n  controls.track.onclick = e =&gt; {\n    if(dragging) return;\n    changed = false;\n    const r = controls.zone.getBoundingClientRect();\n    const t = clamp(0, 1, (pointer(e).clientX - r.left) / r.width);\n    const v = min + t * (max - min);\n    const [vmin, vmax] = value, d = vmax - vmin;\n    if(v &lt; vmin) setValue(v, v + d);\n    else if(v &gt; vmax) setValue(v - d, v);\n    if(changed) dispatch('change');\n  };\n  \n  return dom;\n}\n\nfunction randomScope(prefix = 'scope-') {\n  return prefix + (performance.now() + Math.random()).toString(32).replace('.', '-');\n}\n\ncssLength = v =&gt; v == null ? null : typeof v === 'number' ? `${v}px` : `${v}`\n\nhtml = htl.html\n\ntheme_Flat = `\n/* Options */\n:scope {\n  color: #3b99fc;\n  width: 240px;\n}\n\n:scope {\n  position: relative;\n  display: inline-block;\n  --thumb-size: 15px;\n  --thumb-radius: calc(var(--thumb-size) / 2);\n  padding: var(--thumb-radius) 0;\n  margin: 2px;\n  vertical-align: middle;\n}\n:scope .range-track {\n  box-sizing: border-box;\n  position: relative;\n  height: 7px;\n  background-color: hsl(0, 0%, 80%);\n  overflow: visible;\n  border-radius: 4px;\n  padding: 0 var(--thumb-radius);\n}\n:scope .range-track-zone {\n  box-sizing: border-box;\n  position: relative;\n}\n:scope .range-select {\n  box-sizing: border-box;\n  position: relative;\n  left: var(--range-min);\n  width: calc(var(--range-max) - var(--range-min));\n  cursor: ew-resize;\n  background: currentColor;\n  height: 7px;\n  border: inherit;\n}\n/* Expands the hotspot area. */\n:scope .range-select:before {\n  content: \"\";\n  position: absolute;\n  width: 100%;\n  height: var(--thumb-size);\n  left: 0;\n  top: calc(2px - var(--thumb-radius));\n}\n:scope .range-select:focus,\n:scope .thumb:focus {\n  outline: none;\n}\n:scope .thumb {\n  box-sizing: border-box;\n  position: absolute;\n  width: var(--thumb-size);\n  height: var(--thumb-size);\n\n  background: #fcfcfc;\n  top: -4px;\n  border-radius: 100%;\n  border: 1px solid hsl(0,0%,55%);\n  cursor: default;\n  margin: 0;\n}\n:scope .thumb:active {\n  box-shadow: inset 0 var(--thumb-size) #0002;\n}\n:scope .thumb-min {\n  left: calc(-1px - var(--thumb-radius));\n}\n:scope .thumb-max {\n  right: calc(-1px - var(--thumb-radius));\n}\n`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot = import(\"https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm\")\n\n// load and authorize redivis\nredivis = require(\"redivis\")\n//auth = redivis.authorize({ apiToken: REDIVIS_API_TOKEN })\n\n// formatting function for how two ended slider displays selected range\ninterval_format = ([start, end]) =&gt; `[${start}, ${end}]`\n\n// array of seasons for season selector\nseasons = [\"spring\", \"summer\", \"fall\", \"winter\"]\n\n// all segments\ns = transpose(segments)\n\n// all segments' data\nd = transpose(data).map(d =&gt; ({ ...d, time: new Date(d.time) }))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nns = Inputs.text().classList[0]\n\n// custom css to override some ojs defaults for inputs\nhtml`&lt;style&gt;\n\n  .${ns} {\n    --label-width: 70px;\n  }\n\n  .${ns} div label {\n    background-color: #f4f4f4;\n    padding: 0.25rem 0.5rem;\n    border-radius: 0.5rem;\n    margin-right: 0.25rem;\n    width: auto;\n  }\n  \n  .${ns} div label:hover,\n  .${ns} div label:active,\n  .${ns} div label:focus {\n    background-color: #cdecff;\n  }\n  \n  .${ns} div input[type=\"number\"] {\n    background-color: #f4f4f4;\n    padding: 0.25rem 0.5rem;\n    border-radius: 0.5rem;\n    flex-shrink: 3;\n    border: none;\n  }\n  \n  .${ns} select {\n    background-color: #f4f4f4;\n    border: none;\n    border-radius: 0.5rem;\n    padding: 0.25rem 0.5rem;\n    width: auto;\n  }\n  \n}\n&lt;/style&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUse these filters to narrow down the list of segments, and then select an individual segment from this list below to visualize its trajectory and telemetry. The cursor hover text on the map is the segment ID.\n\n\n\n// filter by season(s)\nviewof season = Inputs.checkbox(seasons, {value: seasons, label: \"Season (astronomical, northern hemisphere)\"})\n\n\n\n\n\n\n\n// filter by range of longitudes\nviewof longitude_range = interval([-180, 180], {\n  step: 1, label: \"Longitudes\", width: \"80%\", format: interval_format\n})\n\n\n\n\n\n\n\n// filter by range of latitudes\nviewof latitude_range = interval([-90, 90], {\n  step: 1, label: \"Latitudes\", width: \"80%\", format: interval_format\n})\n\n\n\n\n\n\n\n// filter by range of durations\nviewof duration_range = interval([0, 100], {\n  step: 1, label: \"Duration (days)\", width: \"80%\", format: interval_format\n})\n\n\n\n\n\n\n\n\n\nfunction download(filename, text) {\n  var element = document.createElement(\"a\");\n  element.setAttribute(\n    \"href\",\n    \"data:text/csv;charset=utf-8,\" + encodeURIComponent(text)\n  );\n  element.setAttribute(\"download\", filename);\n\n  element.style.display = \"none\";\n  document.body.appendChild(element);\n\n  element.click();\n\n  document.body.removeChild(element);\n}\n\n// callback helper -- array to csv\nfunction convertToCSV(arr) {\n  const array = [Object.keys(arr[0])].concat(arr);\n\n  return array\n    .map((it) =&gt; {\n      return Object.values(it).toString();\n    })\n    .join(\"\\n\");\n}\n\n// download data button\ndownload_button = {\n  let button = Inputs.button(html`Download ${sf.length} segment${sf.length != 1 ? \"s\" : \"\"} (downsampled)`);\n  button.addEventListener(\"click\", function () {\n    download(\"project_loon_filtered.csv\", convertToCSV(df));\n  });\n  return button;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction fillTemplate(template, values) {\n  return template.replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) =&gt; {\n    return values[key] !== undefined ? values[key] : match;\n  });\n};\n\nfunction generateSeasonCondition(seasons) {\n  if (!seasons || seasons.length === 0) {\n    return '';\n  }\n  return seasons.map(season =&gt; `segments.${season}`).join(' OR ');\n}\n\n// read in template files\nsql_template = FileAttachment(\"resources/templates/query.sql\").text();\nr_template = FileAttachment(\"resources/templates/query_snippet.R\").text();\npy_template = FileAttachment(\"resources/templates/query_snippet.py\").text();\n\n// create sql query using input filter values, indent all lines\nsql_query = fillTemplate(sql_template, {\n  longitude_min: longitude_range[0],\n  longitude_max: longitude_range[1],\n  latitude_min: latitude_range[0],\n  latitude_max: latitude_range[1],\n  duration_min: duration_range[0],\n  duration_max: duration_range[1],\n  season_statement: generateSeasonCondition(season)\n}).replace(/^/gm, '  ');\n\n\n// create r and python code snippets with sql query\nr_snippet = () =&gt; fillTemplate(r_template, { query: sql_query });\npy_snippet = () =&gt; fillTemplate(py_template.trim(), { query: sql_query });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// modified from:\n// https://github.com/jimjam-slam/quarto-experiments/tree/main/modal-dialog\n\nhtml`\n&lt;a href=\"#\" data-micromodal-trigger=\"mymodal\" tabindex=\"0\"&gt;\n  &lt;i class=\"bi bi-clipboard-data\"&gt;&lt;/i&gt;\n  Generate code snippet\n&lt;/a&gt;\n`\n\n\n\n\n\n\n\nmicro = require(\"micromodal@0.4.10\");\nm = micro.init({\n  awaitOpenAnimation: true,\n  awaitCloseAnimation: true\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData query code snippet\n\n\nRPython\n\n\n\nhtml`\n&lt;div class=\"sourceCode\"&gt;\n&lt;pre class=\"sourceCode r code-with-copy\"&gt;\n&lt;code class=\"sourceCode r\"&gt;\n&lt;span&gt;${r_snippet()}&lt;/span&gt;\n&lt;/code&gt;\n&lt;button title=\"Copy to Clipboard\" class=\"code-copy-button\"&gt;&lt;i class=\"bi\"&gt;&lt;/i&gt;&lt;/button&gt;\n&lt;/pre&gt;\n&lt;/div&gt;\n`\n\n\n\n\n\n\n\n\n\nhtml`\n&lt;div class=\"sourceCode\"&gt;\n&lt;pre class=\"sourceCode python code-with-copy\"&gt;\n&lt;code class=\"sourceCode python\"&gt;\n&lt;span&gt;${py_snippet()}&lt;/span&gt;\n&lt;/code&gt;\n&lt;button title=\"Copy to Clipboard\" class=\"code-copy-button\"&gt;&lt;i class=\"bi\"&gt;&lt;/i&gt;&lt;/button&gt;\n&lt;/pre&gt;\n&lt;/div&gt;\n`"
  },
  {
    "objectID": "index.html#data-query-code-snippet",
    "href": "index.html#data-query-code-snippet",
    "title": "Project Loon",
    "section": "Data query code snippet",
    "text": "Data query code snippet"
  },
  {
    "objectID": "index.html#individual-segment-trajectory",
    "href": "index.html#individual-segment-trajectory",
    "title": "Project Loon",
    "section": "Individual segment trajectory",
    "text": "Individual segment trajectory\nd_found = sf.length &gt; 0\n// display error is no matches\nd_found ? html`&lt;div&gt;&lt;/div&gt;` : html`&lt;p class=\"filter-error\"&gt;&lt;i class=\"bi bi-exclamation-triangle\"&gt;&lt;/i&gt; No segments match selected filters&lt;/p&gt;`\ndg = d3.group(df, d =&gt; d.segment_id)\n// selector for individual segment\nviewof ds = Inputs.select(dg, {\n  value: dg.get(112), // default segment\n  format: ([k, v]) =&gt; `Segment ${k} (Flight ${v[0].flight_id})`\n})\n\nasync function getSegment(seg_id) {\n  const rows = await redivis\n    .user('SDSS')\n    .dataset('project_loon')\n    .query(`\n       SELECT *\n       FROM loon\n       WHERE segment_id = ${seg_id}\n    `)\n    .listRows()\n  return rows;\n}\n\nviewof download_button_segment = {\n  let button = Inputs.button(\"Download segment\");\n  button.addEventListener(\"click\", async function () {\n    const df_full = await getSegment(ds[0].segment_id);\n    download(\"project_loon_filtered.csv\", convertToCSV(df_full));\n  });\n  return button;\n}\n\nd_found ? html`&lt;div class=\"segment-buttons\"&gt;${viewof ds} ${viewof download_button_segment}&lt;/div&gt;` : html`&lt;div&gt;&lt;/div&gt;`\nstart_color = \"var(--bs-success)\"\nend_color = \"var(--bs-danger)\"\n\n// function for how to format data on map\nprint_date = d =&gt; d.toISOString().split('T')[0]\n\n// map -- whole world equirectangular\nd_found ? Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  projection: { type: \"equirectangular\" },\n  marks: [\n    Plot.frame(),\n    Plot.graticule(),\n    Plot.geo(ocean, {fill: ocean_color, opacity: 0.7}),\n    Plot.geo(land, {fill: land_color}),\n    // trajectory path\n    Plot.line(ds, {\n      x: \"longitude\", y: \"latitude\",\n      r: 1, stroke: \"black\", strokeOpacity: 0.3,\n    }),\n    // start marker\n    Plot.dot(ds.slice(0, 1), {\n      x: \"longitude\", y: \"latitude\",\n      r: 3, fill: start_color, symbol: \"triangle\"\n    }),\n    // start date text\n    Plot.text(ds.slice(0, 1), {\n      x: \"longitude\", y: \"latitude\",\n      text: d =&gt; print_date(d.time), dy: -7, lineAnchor: \"bottom\", fontSize: 14\n    }),\n    // end marker\n    Plot.dot(ds.slice(ds.length - 1, ds.length), {\n      x: \"longitude\", y: \"latitude\",\n      r: 3, fill: end_color, symbol: \"square\"\n    }),\n    // end date text\n    Plot.text(ds.slice(ds.length - 1, ds.length), {\n      x: \"longitude\", y: \"latitude\",\n      text: d =&gt; print_date(d.time), dy: -7, lineAnchor: \"bottom\", fontSize: 14\n    })\n  ],\n}) : html`&lt;div&gt;&lt;/div&gt;`\nget_circle = (seg) =&gt; {\n  // find min and max longitude and latitude\n  const minLon = d3.min(seg.map(d =&gt; d.longitude))\n  const maxLon = d3.max(seg.map(d =&gt; d.longitude))\n  const minLat = d3.min(seg.map(d =&gt; d.latitude))\n  const maxLat = d3.max(seg.map(d =&gt; d.latitude))\n  // define rectangle with min/max long/lat corners\n  const corners = [[minLon, minLat], [minLon, maxLat], [maxLon, minLat], [maxLon, maxLat]]\n  // find rectangle's center\n  const center = [(minLon + maxLon) / 2, (minLat + maxLat) / 2]\n  // find max of geo distances from each corner to center\n  const dist = d3.max(corners, corner =&gt; d3.geoDistance(center, corner))\n  // turn geo distance into radius\n  const radius = dist * (180 / Math.PI)\n  // define geo circle with computed center and radius\n  const circle = d3.geoCircle().center(center).radius(radius)()\n  return circle\n}\n\n// find above circle\ncircle = d_found ? get_circle(ds) : null\n\n// map -- zoomed in azimuthal\nd_found ? Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  projection: { type: \"azimuthal-equidistant\", domain: circle },\n  marks: [\n    Plot.frame(),\n    Plot.graticule(),\n    Plot.geo(ocean, {fill: ocean_color, opacity: 0.7}),\n    Plot.geo(land, {fill: land_color}),\n    // trajectory path\n    Plot.line(ds, {\n      x: \"longitude\", y: \"latitude\",\n      r: 1, stroke: \"black\", strokeOpacity: 0.3,\n    }),\n    // start marker\n    Plot.dot(ds.slice(0, 1), {\n      x: \"longitude\", y: \"latitude\",\n      r: 6, fill: start_color, symbol: \"triangle\"\n    }),\n    // start date text\n    Plot.text(ds.slice(0, 1), {\n      x: \"longitude\", y: \"latitude\",\n      text: d =&gt; print_date(d.time), dy: -8, lineAnchor: \"bottom\", fontSize: 14\n    }),\n    // end marker\n    Plot.dot(ds.slice(ds.length - 1, ds.length), {\n      x: \"longitude\", y: \"latitude\",\n      r: 6, fill: end_color, symbol: \"square\"\n    }),\n    // end date text\n    Plot.text(ds.slice(ds.length - 1, ds.length), {\n      x: \"longitude\", y: \"latitude\",\n      text: d =&gt; print_date(d.time), dy: -8, lineAnchor: \"bottom\", fontSize: 14\n    })\n  ],\n}) : html`&lt;div&gt;&lt;/div&gt;`\nviewof scatter_altitude = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  width: 900,\n  height: 200,\n  inset: 8,\n  grid: true,\n  y: { label: \"Altitude (meters)\" },\n  marks: [\n    Plot.frame(),\n    Plot.dot(ds, { x: \"time\", y: \"altitude\", r: 0.5 }),\n  ]\n})\n\nd_found ? html`\n  &lt;form&gt;&lt;label&gt;Altitude&lt;/label&gt;&lt;/form&gt;\n  ${viewof scatter_altitude}\n` : html`&lt;div&gt;&lt;/div&gt;`\nwinds = new Map([[\"Zonal (east-west)\", \"wind_u\"],\n                 [\"Meridional (north-south)\", \"wind_v\"]])\nviewof y_wind = Inputs.select(winds, {label: \"Wind\"})\n\nviewof scatter_wind = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  width: 900,\n  height: 200,\n  inset: 8,\n  grid: true,\n  y: { label: \"Velocity (meters/second)\" },\n  marks: [\n    Plot.frame(),\n    Plot.dot(ds, { x: \"time\", y: y_wind, r: 0.5 }),\n  ]\n})\n\nd_found ? html`\n  ${viewof y_wind}\n  ${viewof scatter_wind}\n` : html`&lt;div&gt;&lt;/div&gt;`\nfluxes = new Map([[\"Total\", \"flux_total\"],\n                  [\"Eastward\", \"flux_east\"],\n                  [\"Westward\", \"flux_west\"],\n                  [\"Northward\", \"flux_north\"],\n                  [\"Southward\", \"flux_south\"]])\nviewof y_flux = Inputs.select(fluxes, {label: \"Flux\"})\n\nviewof scatter_flux = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  width: 900,\n  height: 200,\n  inset: 8,\n  grid: true,\n//  y: { label: \"Flux (millipascals)\", transform: (f) =&gt; Math.abs(f * 1000) },\n  y: { label: \"Flux (log mPa)\", transform: (f) =&gt; Math.log(Math.abs(f * 1000)) },\n  marks: [\n    Plot.frame(),\n    Plot.dot(ds, { x: \"time\", y: y_flux, r: 0.5 }),\n  ]\n})\n\nd_found ? html`\n  ${viewof y_flux}\n  ${viewof scatter_flux}\n` : html`&lt;div&gt;&lt;/div&gt;`\n// data table for selected segment's data\nd_found ? Inputs.table(ds) : html`&lt;div&gt;&lt;/div&gt;`"
  }
]