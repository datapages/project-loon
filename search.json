[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Project Loon",
    "section": "",
    "text": "Welcome to the datapage for Project Loon data! This dataset consists of 385 balloon flights, split into 938 data segments. For more details on the dataset, please see the About tab. On this page, we offer several tools to select and visualize data from individual balloons. The raw data can be viewed and downloaded from the Data tab, and the Analysis tab offers other data access and analysis tools. We’re currently working on more tools to visualize and access the data, so stay tuned!\n\n\n\n\n\n\n\nImage from Wikipedia by Flickr user Wasting Frames, license CC BY 2.0.\n\n\n\n\n\n\nimport {interval} from '@mootari/range-slider' // two ended slider\ninterval_format = ([start, end]) =&gt; `[${start}, ${end}]`\n\nseasons = [\"spring\", \"summer\", \"fall\", \"winter\"]\nfilter_error = '&lt;p class=\"filter-error\"&gt;&lt;i class=\"bi bi-exclamation-triangle\"&gt;&lt;/i&gt; No segments match selected filters&lt;/p&gt;'\n\n// all segments\ns = transpose(segments)\n\n// all segments' data\nd = transpose(data).map(d =&gt; ({ ...d, time: new Date(d.time) }))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nns = Inputs.text().classList[0]\n\n// custom css to override some ojs defaults for inputs\nhtml`&lt;style&gt;\n\n  .${ns} {\n    --label-width: 70px;\n  }\n\n  .${ns} div label {\n    background-color: #f4f4f4;\n    padding: 0.25rem 0.5rem;\n    border-radius: 0.5rem;\n    margin-right: 0.25rem;\n    width: auto;\n  }\n  \n  .${ns} div label:hover,\n  .${ns} div label:active,\n  .${ns} div label:focus {\n    background-color: #cdecff;\n  }\n  \n  .${ns} div input[type=\"number\"] {\n    background-color: #f4f4f4;\n    padding: 0.25rem 0.5rem;\n    border-radius: 0.5rem;\n    flex-shrink: 3;\n    border: none;\n  }\n  \n  .${ns} select {\n    background-color: #f4f4f4;\n    border: none;\n    border-radius: 0.5rem;\n    padding: 0.25rem 0.5rem;\n    width: auto;\n  }\n}\n&lt;/style&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUse these filters to narrow down the list of segments, and then select an individual segment from this list below to visualize its trajectory and telemetry.\n\n\n// filter by season(s)\nviewof season = Inputs.checkbox(seasons, {value: seasons, label: \"Season (astronomical, northern hemisphere)\"})\n//viewof season = Inputs.checkbox(seasons, {value: [\"winter\"], label: \"Season (astronomical)\"})\n\n\n\n\n\n\n\n// filter by range of longitudes\nviewof longitude_range = interval([-180, 180], {\n  step: 1, label: \"Longitudes\", width: \"80%\", format: interval_format\n})\n\n\n\n\n\n\n\n// filter by range of latitudes\nviewof latitude_range = interval([-90, 90], {\n  step: 1, label: \"Latitudes\", width: \"80%\", format: interval_format\n})\n\n\n\n\n\n\n\n// filter by range of durations\nviewof duration_range = interval([0, 100], {\n  step: 1, label: \"Duration (days)\", width: \"80%\", format: interval_format\n})\n\n\n\n\n\n\n\n\nsf = s.filter(d =&gt; season.some(se =&gt; d.season.includes(se)))\n      .filter(d =&gt; d.longitude_min &lt;= longitude_range[1] &\n                   d.longitude_max &gt;= longitude_range[0])\n      .filter(d =&gt; d.latitude_min &lt;= latitude_range[1] &\n                   d.latitude_max &gt;= latitude_range[0])\n      .filter(d =&gt; d.duration &gt;= duration_range[0] &\n                   d.duration &lt;= duration_range[1])\n\n// filtered segments' IDs\nsf_id = sf.map(d =&gt; d.segment_id)\n\n// filtered segments' data\ndf = d.filter(d =&gt; sf_id.includes(d.segment_id))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nland = FileAttachment(\"topo/ne_110m_land.json\").json()\nocean = FileAttachment(\"topo/ne_110m_ocean.json\").json()\n\nland_color = \"wheat\"\nocean_color = \"#8398aa\"\n\n// map -- globe\nviewof map_globe = Plot.plot({\n  width: 400,\n  projection: {type: \"orthographic\", rotate: [-longitude, -latitude]},\n  marks: [\n    Plot.sphere(),\n    Plot.graticule(),\n    Plot.geo(ocean, {fill: ocean_color, opacity: 0.7}),\n    Plot.geo(land, {fill: land_color}),\n    Plot.line(df, {\n      x: \"longitude\", y: \"latitude\", z: \"segment_id\",\n      r: 0.7, stroke: \"grey\", strokeOpacity: 0.7,\n    }),\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof longitude = Inputs.range([-180, 180], {label: \"Longitude\", step: 1, value: -30})\nviewof latitude = Inputs.range([-90, 90], {label: \"Latitude\", step: 1, value: 0})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nd_found = sf.length &gt; 0\nhtml`${d_found ? '' : filter_error}`\ndg = d3.group(df, d =&gt; d.segment_id)\nviewof ds = Inputs.select(dg, {\n  value: dg.get(112),\n  format: ([k, v]) =&gt; `Segment ${k} (Flight ${v[0].flight_id})`\n})\nstart_color = \"var(--bs-success)\"\nend_color = \"var(--bs-danger)\"\n\nprint_date = d =&gt; d.toISOString().split('T')[0]\n// map -- whole world equirectangular\nd_found ? Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  projection: { type: \"equirectangular\" },\n  marks: [\n    //Plot.sphere(),\n    Plot.frame(),\n    Plot.graticule(),\n    Plot.geo(ocean, {fill: ocean_color, opacity: 0.7}),\n    Plot.geo(land, {fill: land_color}),\n    //Plot.geo(land, {fill: \"lightgrey\"}),\n    Plot.line(ds, {\n      x: \"longitude\", y: \"latitude\",\n      r: 1, stroke: \"black\", strokeOpacity: 0.3,\n    }),\n    Plot.dot(ds.slice(0, 1), {\n      x: \"longitude\", y: \"latitude\",\n      r: 3, fill: start_color, symbol: \"triangle\"\n    }),\n    Plot.text(ds.slice(0, 1), {\n      x: \"longitude\", y: \"latitude\",\n      text: d =&gt; print_date(d.time), dy: -7, lineAnchor: \"bottom\"\n    }),\n    Plot.dot(ds.slice(ds.length - 1, ds.length), {\n      x: \"longitude\", y: \"latitude\",\n      r: 3, fill: end_color, symbol: \"square\"\n    }),\n    Plot.text(ds.slice(ds.length - 1, ds.length), {\n      x: \"longitude\", y: \"latitude\",\n      text: d =&gt; print_date(d.time), dy: -7, lineAnchor: \"bottom\"\n    })\n  ],\n}) : html``\nget_circle = (seg) =&gt; {\n  const minLon = d3.min(seg.map(d =&gt; d.longitude))\n  const maxLon = d3.max(seg.map(d =&gt; d.longitude))\n  const minLat = d3.min(seg.map(d =&gt; d.latitude))\n  const maxLat = d3.max(seg.map(d =&gt; d.latitude))\n  const center = [(minLon + maxLon) / 2, (minLat + maxLat) / 2]\n  const corners = [[minLon, minLat], [minLon, maxLat], [maxLon, minLat], [maxLon, maxLat]]\n  const dist = d3.max(corners, corner =&gt; d3.geoDistance(center, corner))\n  const radius = dist * (180 / Math.PI)\n  const circle = d3.geoCircle().center(center).radius(radius)()\n  return circle\n}\n\ncircle = d_found ? get_circle(ds) : null\n\n// map -- zoomed in azimuthal\nd_found ? Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  projection: { type: \"azimuthal-equidistant\", domain: circle },\n  marks: [\n    Plot.frame(),\n    Plot.graticule(),\n    Plot.geo(ocean, {fill: ocean_color, opacity: 0.7}),\n    Plot.geo(land, {fill: land_color}),\n    //Plot.geo(land, {fill: \"lightgrey\"}),\n    Plot.line(ds, {\n      x: \"longitude\", y: \"latitude\",\n      r: 1, stroke: \"black\", strokeOpacity: 0.3,\n    }),\n    Plot.dot(ds.slice(0, 1), {\n      x: \"longitude\", y: \"latitude\",\n      r: 6, fill: start_color, symbol: \"triangle\"\n    }),\n    Plot.text(ds.slice(0, 1), {\n      x: \"longitude\", y: \"latitude\",\n      text: d =&gt; print_date(d.time), dy: -7, lineAnchor: \"bottom\"\n    }),\n    Plot.dot(ds.slice(ds.length - 1, ds.length), {\n      x: \"longitude\", y: \"latitude\",\n      r: 6, fill: end_color, symbol: \"square\"\n    }),\n    Plot.text(ds.slice(ds.length - 1, ds.length), {\n      x: \"longitude\", y: \"latitude\",\n      text: d =&gt; print_date(d.time), dy: -7, lineAnchor: \"bottom\"\n    })\n  ],\n}) : html``\nviewof scatter_altitude = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  width: 900,\n  height: 200,\n  inset: 8,\n  grid: true,\n  y: { label: \"Altitude (meters)\" },\n  marks: [\n    Plot.frame(),\n    Plot.dot(ds, { x: \"time\", y: \"altitude\", r: 0.5 }),\n  ]\n})\n\nd_found ? html`\n  &lt;form&gt;&lt;label&gt;Altitude&lt;/label&gt;&lt;/form&gt;\n  ${viewof scatter_altitude}\n` : html``\nwinds = new Map([[\"Zonal (east-west)\", \"wind_u\"],\n                 [\"Meridional (north-south)\", \"wind_v\"]])\nviewof y_wind = Inputs.select(winds, {label: \"Wind\"})\n\nviewof scatter_wind = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  width: 900,\n  height: 200,\n  inset: 8,\n  grid: true,\n  y: { label: \"Velocity (meters/second)\" },\n  marks: [\n    Plot.frame(),\n    Plot.dot(ds, { x: \"time\", y: y_wind, r: 0.5 }),\n  ]\n})\n\nd_found ? html`\n  ${viewof y_wind}\n  ${viewof scatter_wind}\n` : html``\nfluxes = new Map([[\"Total\", \"flux_total\"],\n                  [\"Eastward\", \"flux_east\"],\n                  [\"Westward\", \"flux_west\"],\n                  [\"Northward\", \"flux_north\"],\n                  [\"Southward\", \"flux_south\"]])\nviewof y_flux = Inputs.select(fluxes, {label: \"Flux\"})\n\nviewof scatter_flux = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  width: 900,\n  height: 200,\n  inset: 8,\n  grid: true,\n  y: { label: \"Flux (millipascals)\", transform: (f) =&gt; Math.abs(f * 1000) },\n  marks: [\n    Plot.frame(),\n    Plot.dot(ds, { x: \"time\", y: y_flux, r: 0.5 }),\n  ]\n})\n\nd_found ? html`\n  ${viewof y_flux}\n  ${viewof scatter_flux}\n` : html``"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Project Loon",
    "section": "",
    "text": "The purpose of this dataset is to offer an estimate of the horizontal momentum fluxed vertically by the atmospheric internal gravity waves (GWs) observed by Project Loon balloons. This vertical flux of horizontal momentum is commonly referred to as the GW momentum flux. Before estimating the GW momentum fluxes, additional processing was necessary to remove data sampling errors, irregularities, and balloon maneuvering.\n\n\n\nThe procedures for this processing, and the subsequent analysis of the processed data, are described in Green et al. (2024). The Python code (in Jupyter notebooks) that was used for both is available at: https://github.com/DataWaveProject/Loon-momentum-fluxes.\n\n\n\nSee the following sample project for examples: https://redivis.com/projects/q08b-889vc3xgg."
  },
  {
    "objectID": "about.html#project-loon",
    "href": "about.html#project-loon",
    "title": "Project Loon",
    "section": "",
    "text": "The purpose of this dataset is to offer an estimate of the horizontal momentum fluxed vertically by the atmospheric internal gravity waves (GWs) observed by Project Loon balloons. This vertical flux of horizontal momentum is commonly referred to as the GW momentum flux. Before estimating the GW momentum fluxes, additional processing was necessary to remove data sampling errors, irregularities, and balloon maneuvering.\n\n\n\nThe procedures for this processing, and the subsequent analysis of the processed data, are described in Green et al. (2024). The Python code (in Jupyter notebooks) that was used for both is available at: https://github.com/DataWaveProject/Loon-momentum-fluxes.\n\n\n\nSee the following sample project for examples: https://redivis.com/projects/q08b-889vc3xgg."
  },
  {
    "objectID": "analysis.html",
    "href": "analysis.html",
    "title": "Project Loon",
    "section": "",
    "text": "You can access the project_loon data programmatically using the Redivis API for R or Python.\n\nRPython\n\n\n\nInstall the redivis-r package:\n\ndevtools::install_github(\"redivis/redivis-r\")\n\nGenerate and set an API token.\nAccess the data:\n\nlibrary(redivis)\n\nuser &lt;- redivis::user(\"sdss\")\ndataset &lt;- user$dataset(\"project_loon\")\ntable &lt;- dataset$table(\"loon\")\n\n# Load table as tidyverse tibble\ndf &lt;- table$to_tibble()\nView documentation\n\n\n\nInstall the redivis-python client library:\n\npip install --upgrade redivis\n\nGenerate and set an API token.\nAccess the data:\n\nimport redivis\n\nuser = redivis.user(\"sdss\")\ndataset = user.dataset(\"project_loon\")\ntable = dataset.table(\"loon\")\n\n# Load table as a dataframe\ndf = table.to_pandas_dataframe()\nView documentation"
  },
  {
    "objectID": "analysis.html#programmatic-access",
    "href": "analysis.html#programmatic-access",
    "title": "Project Loon",
    "section": "",
    "text": "You can access the project_loon data programmatically using the Redivis API for R or Python.\n\nRPython\n\n\n\nInstall the redivis-r package:\n\ndevtools::install_github(\"redivis/redivis-r\")\n\nGenerate and set an API token.\nAccess the data:\n\nlibrary(redivis)\n\nuser &lt;- redivis::user(\"sdss\")\ndataset &lt;- user$dataset(\"project_loon\")\ntable &lt;- dataset$table(\"loon\")\n\n# Load table as tidyverse tibble\ndf &lt;- table$to_tibble()\nView documentation\n\n\n\nInstall the redivis-python client library:\n\npip install --upgrade redivis\n\nGenerate and set an API token.\nAccess the data:\n\nimport redivis\n\nuser = redivis.user(\"sdss\")\ndataset = user.dataset(\"project_loon\")\ntable = dataset.table(\"loon\")\n\n# Load table as a dataframe\ndf = table.to_pandas_dataframe()\nView documentation"
  }
]