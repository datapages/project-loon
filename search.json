[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Project Loon",
    "section": "",
    "text": "Welcome to the datapage for Project Loon data! This dataset consists of 385 balloon flights, split into 938 data segments. For more details on the dataset, please see the About tab. On this page, we offer several tools to select and visualize data from individual balloons. The raw data can be viewed and downloaded from the Data tab, and the Analysis tab offers other data access and analysis tools. We’re currently working on more tools to visualize and access the data, so stay tuned!\n\n\n\n\n\n\n\nImage from Wikipedia by Flickr user Wasting Frames, license CC BY 2.0.\n\n\n\n\n\n\nfunction interval(range = [], options = {}) {\n  const [min = 0, max = 1] = range;\n  const {\n    step = .001,\n    label = null,\n    value = [min, max],\n    format = ([start, end]) =&gt; `${start} … ${end}`,\n    color,\n    width,\n    theme,\n    __ns__ = randomScope(),\n  } = options;\n\n  const css = `\n#${__ns__} {\n  font: 13px/1.2 var(--sans-serif);\n  display: flex;\n  align-items: baseline;\n  flex-wrap: wrap;\n  max-width: 100%;\n  width: auto;\n}\n@media only screen and (min-width: 30em) {\n  #${__ns__} {\n    flex-wrap: nowrap;\n    width: 360px;\n  }\n}\n#${__ns__} .label {\n  width: 120px;\n  padding: 5px 0 4px 0;\n  margin-right: 6.5px;\n  flex-shrink: 0;\n}\n#${__ns__} .form {\n  display: flex;\n  width: 100%;\n}\n#${__ns__} .range {\n  flex-shrink: 1;\n  width: 100%;\n}\n#${__ns__} .range-slider {\n  width: 100%;\n}\n  `;\n  \n  const $range = rangeInput({min, max, value: [value[0], value[1]], step, color, width, theme});\n  const $output = html`&lt;output&gt;`;\n  const $view = html`&lt;div id=${__ns__}&gt;\n${label == null ? '' : html`&lt;div class=\"label\"&gt;${label}`}\n&lt;div class=form&gt;\n  &lt;div class=range&gt;\n    ${$range}&lt;div class=range-output&gt;${$output}&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n${html`&lt;style&gt;${css}`}\n  `;\n\n  const update = () =&gt; {\n    const content = format([$range.value[0], $range.value[1]]);\n    if(typeof content === 'string') $output.value = content;\n    else {\n      while($output.lastChild) $output.lastChild.remove();\n      $output.appendChild(content);\n    }\n  };\n  $range.oninput = update;\n  update();\n  \n  return Object.defineProperty($view, 'value', {\n    get: () =&gt; $range.value,\n    set: ([a, b]) =&gt; {\n      $range.value = [a, b];\n      update();\n    },\n  });\n}\n\nfunction rangeInput(options = {}) {\n  const {\n    min = 0,\n    max = 100,\n    step = 'any',\n    value: defaultValue = [min, max],\n    color,\n    width,\n    theme = theme_Flat,\n  } = options;\n  \n  const controls = {};\n  const scope = randomScope();\n  const clamp = (a, b, v) =&gt; v &lt; a ? a : v &gt; b ? b : v;\n\n  // Will be used to sanitize values while avoiding floating point issues.\n  const input = html`&lt;input type=range ${{min, max, step}}&gt;`;\n  \n  const dom = html`&lt;div class=${`${scope} range-slider`} style=${{\n    color,\n    width: cssLength(width),\n  }}&gt;\n  ${controls.track = html`&lt;div class=\"range-track\"&gt;\n    ${controls.zone = html`&lt;div class=\"range-track-zone\"&gt;\n      ${controls.range = html`&lt;div class=\"range-select\" tabindex=0&gt;\n        ${controls.min = html`&lt;div class=\"thumb thumb-min\" tabindex=0&gt;`}\n        ${controls.max = html`&lt;div class=\"thumb thumb-max\" tabindex=0&gt;`}\n      `}\n    `}\n  `}\n  ${html`&lt;style&gt;${theme.replace(/:scope\\b/g, '.'+scope)}`}\n&lt;/div&gt;`;\n\n  let value = [], changed = false;\n  Object.defineProperty(dom, 'value', {\n    get: () =&gt; [...value],\n    set: ([a, b]) =&gt; {\n      value = sanitize(a, b);\n      updateRange();\n    },\n  });\n\n  const sanitize = (a, b) =&gt; {\n    a = isNaN(a) ? min : ((input.value = a), input.valueAsNumber);\n    b = isNaN(b) ? max : ((input.value = b), input.valueAsNumber);\n    return [Math.min(a, b), Math.max(a, b)];\n  }\n  \n  const updateRange = () =&gt; {\n    const ratio = v =&gt; (v - min) / (max - min);\n    dom.style.setProperty('--range-min', `${ratio(value[0]) * 100}%`);\n    dom.style.setProperty('--range-max', `${ratio(value[1]) * 100}%`);\n  };\n\n  const dispatch = name =&gt; {\n    dom.dispatchEvent(new Event(name, {bubbles: true}));\n  };\n  const setValue = (vmin, vmax) =&gt; {\n    const [pmin, pmax] = value;\n    value = sanitize(vmin, vmax);\n    updateRange();\n    // Only dispatch if values have changed.\n    if(pmin === value[0] && pmax === value[1]) return;\n    dispatch('input');\n    changed = true;\n  };\n  \n  setValue(...defaultValue);\n  \n  // Mousemove handlers.\n  const handlers = new Map([\n    [controls.min, (dt, ov) =&gt; {\n      const v = clamp(min, ov[1], ov[0] + dt * (max - min));\n      setValue(v, ov[1]);\n    }],\n    [controls.max, (dt, ov) =&gt; {\n      const v = clamp(ov[0], max, ov[1] + dt * (max - min));\n      setValue(ov[0], v);\n    }],\n    [controls.range, (dt, ov) =&gt; {\n      const d = ov[1] - ov[0];\n      const v = clamp(min, max - d, ov[0] + dt * (max - min));\n      setValue(v, v + d);\n    }],\n  ]);\n  \n  // Returns client offset object.\n  const pointer = e =&gt; e.touches ? e.touches[0] : e;\n  // Note: Chrome defaults \"passive\" for touch events to true.\n  const on  = (e, fn) =&gt; e.split(' ').map(e =&gt; document.addEventListener(e, fn, {passive: false}));\n  const off = (e, fn) =&gt; e.split(' ').map(e =&gt; document.removeEventListener(e, fn, {passive: false}));\n  \n  let initialX, initialV, target, dragging = false;\n  function handleDrag(e) {\n    // Gracefully handle exit and reentry of the viewport.\n    if(!e.buttons && !e.touches) {\n      handleDragStop();\n      return;\n    }\n    dragging = true;\n    const w = controls.zone.getBoundingClientRect().width;\n    e.preventDefault();\n    handlers.get(target)((pointer(e).clientX - initialX) / w, initialV);\n  }\n  \n  \n  function handleDragStop(e) {\n    off('mousemove touchmove', handleDrag);\n    off('mouseup touchend', handleDragStop);\n    if(changed) dispatch('change');\n  }\n  \n  invalidation.then(handleDragStop);\n  \n  dom.ontouchstart = dom.onmousedown = e =&gt; {\n    dragging = false;\n    changed = false;\n    if(!handlers.has(e.target)) return;\n    on('mousemove touchmove', handleDrag);\n    on('mouseup touchend', handleDragStop);\n    e.preventDefault();\n    e.stopPropagation();\n    \n    target = e.target;\n    initialX = pointer(e).clientX;\n    initialV = value.slice();\n  };\n  \n  controls.track.onclick = e =&gt; {\n    if(dragging) return;\n    changed = false;\n    const r = controls.zone.getBoundingClientRect();\n    const t = clamp(0, 1, (pointer(e).clientX - r.left) / r.width);\n    const v = min + t * (max - min);\n    const [vmin, vmax] = value, d = vmax - vmin;\n    if(v &lt; vmin) setValue(v, v + d);\n    else if(v &gt; vmax) setValue(v - d, v);\n    if(changed) dispatch('change');\n  };\n  \n  return dom;\n}\n\nfunction randomScope(prefix = 'scope-') {\n  return prefix + (performance.now() + Math.random()).toString(32).replace('.', '-');\n}\n\ncssLength = v =&gt; v == null ? null : typeof v === 'number' ? `${v}px` : `${v}`\n\nhtml = htl.html\n\ntheme_Flat = `\n/* Options */\n:scope {\n  color: #3b99fc;\n  width: 240px;\n}\n\n:scope {\n  position: relative;\n  display: inline-block;\n  --thumb-size: 15px;\n  --thumb-radius: calc(var(--thumb-size) / 2);\n  padding: var(--thumb-radius) 0;\n  margin: 2px;\n  vertical-align: middle;\n}\n:scope .range-track {\n  box-sizing: border-box;\n  position: relative;\n  height: 7px;\n  background-color: hsl(0, 0%, 80%);\n  overflow: visible;\n  border-radius: 4px;\n  padding: 0 var(--thumb-radius);\n}\n:scope .range-track-zone {\n  box-sizing: border-box;\n  position: relative;\n}\n:scope .range-select {\n  box-sizing: border-box;\n  position: relative;\n  left: var(--range-min);\n  width: calc(var(--range-max) - var(--range-min));\n  cursor: ew-resize;\n  background: currentColor;\n  height: 7px;\n  border: inherit;\n}\n/* Expands the hotspot area. */\n:scope .range-select:before {\n  content: \"\";\n  position: absolute;\n  width: 100%;\n  height: var(--thumb-size);\n  left: 0;\n  top: calc(2px - var(--thumb-radius));\n}\n:scope .range-select:focus,\n:scope .thumb:focus {\n  outline: none;\n}\n:scope .thumb {\n  box-sizing: border-box;\n  position: absolute;\n  width: var(--thumb-size);\n  height: var(--thumb-size);\n\n  background: #fcfcfc;\n  top: -4px;\n  border-radius: 100%;\n  border: 1px solid hsl(0,0%,55%);\n  cursor: default;\n  margin: 0;\n}\n:scope .thumb:active {\n  box-shadow: inset 0 var(--thumb-size) #0002;\n}\n:scope .thumb-min {\n  left: calc(-1px - var(--thumb-radius));\n}\n:scope .thumb-max {\n  right: calc(-1px - var(--thumb-radius));\n}\n`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot = import(\"https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm\")\n\n// load and authorize redivis\nredivis = require(\"redivis\")\nauth = redivis.authorize()\n\n// formatting function for how two ended slider displays selected range\ninterval_format = ([start, end]) =&gt; `[${start}, ${end}]`\n\n// array of seasons for season selector\nseasons = [\"spring\", \"summer\", \"fall\", \"winter\"]\n\n// all segments\ns = transpose(segments)\n\n// all segments' data\nd = transpose(data).map(d =&gt; ({ ...d, time: new Date(d.time) }))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nns = Inputs.text().classList[0]\n\n// custom css to override some ojs defaults for inputs\nhtml`&lt;style&gt;\n\n  .${ns} {\n    --label-width: 70px;\n  }\n\n  .${ns} div label {\n    background-color: #f4f4f4;\n    padding: 0.25rem 0.5rem;\n    border-radius: 0.5rem;\n    margin-right: 0.25rem;\n    width: auto;\n  }\n  \n  .${ns} div label:hover,\n  .${ns} div label:active,\n  .${ns} div label:focus {\n    background-color: #cdecff;\n  }\n  \n  .${ns} div input[type=\"number\"] {\n    background-color: #f4f4f4;\n    padding: 0.25rem 0.5rem;\n    border-radius: 0.5rem;\n    flex-shrink: 3;\n    border: none;\n  }\n  \n  .${ns} select {\n    background-color: #f4f4f4;\n    border: none;\n    border-radius: 0.5rem;\n    padding: 0.25rem 0.5rem;\n    width: auto;\n  }\n  \n}\n&lt;/style&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUse these filters to narrow down the list of segments, and then select an individual segment from this list below to visualize its trajectory and telemetry.\n\n\n\n// filter by season(s)\nviewof season = Inputs.checkbox(seasons, {value: seasons, label: \"Season (astronomical, northern hemisphere)\"})\n\n\n\n\n\n\n\n// filter by range of longitudes\nviewof longitude_range = interval([-180, 180], {\n  step: 1, label: \"Longitudes\", width: \"80%\", format: interval_format\n})\n\n\n\n\n\n\n\n// filter by range of latitudes\nviewof latitude_range = interval([-90, 90], {\n  step: 1, label: \"Latitudes\", width: \"80%\", format: interval_format\n})\n\n\n\n\n\n\n\n// filter by range of durations\nviewof duration_range = interval([0, 100], {\n  step: 1, label: \"Duration (days)\", width: \"80%\", format: interval_format\n})\n\n\n\n\n\n\n\n\n\nfunction download(filename, text) {\n  var element = document.createElement(\"a\");\n  element.setAttribute(\n    \"href\",\n    \"data:text/csv;charset=utf-8,\" + encodeURIComponent(text)\n  );\n  element.setAttribute(\"download\", filename);\n\n  element.style.display = \"none\";\n  document.body.appendChild(element);\n\n  element.click();\n\n  document.body.removeChild(element);\n}\n\n// callback helper -- array to csv\nfunction convertToCSV(arr) {\n  const array = [Object.keys(arr[0])].concat(arr);\n\n  return array\n    .map((it) =&gt; {\n      return Object.values(it).toString();\n    })\n    .join(\"\\n\");\n}\n\n// download data button\ndownload_button = {\n  let button = Inputs.button(html`Download ${sf.length} segment${sf.length != 1 ? \"s\" : \"\"} (downsampled)`);\n  button.addEventListener(\"click\", function () {\n    download(\"project_loon_filtered.csv\", convertToCSV(df));\n  });\n  return button;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsf = s.filter(d =&gt; season.some(se =&gt; d.season.includes(se))) // by season\n      .filter(d =&gt; d.longitude_min &lt;= longitude_range[1] & // by longitude\n                   d.longitude_max &gt;= longitude_range[0])\n      .filter(d =&gt; d.latitude_min &lt;= latitude_range[1] & // by latitude\n                   d.latitude_max &gt;= latitude_range[0])\n      .filter(d =&gt; d.duration &gt;= duration_range[0] & // by duration\n                   d.duration &lt;= duration_range[1])\n\n// filtered segments' IDs\nsf_id = sf.map(d =&gt; d.segment_id)\n\n// filtered segments' data\ndf = d.filter(d =&gt; sf_id.includes(d.segment_id))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nland = FileAttachment(\"topo/ne_110m_land.json\").json()\nocean = FileAttachment(\"topo/ne_110m_ocean.json\").json()\n\n// fill colors for land and ocean on maps\nland_color = \"wheat\"\nocean_color = \"#8398aa\"\n\n// map -- globe\nviewof map_globe = Plot.plot({\n  width: 400,\n  projection: {type: \"orthographic\", rotate: [-longitude, -latitude]},\n  marks: [\n    Plot.sphere(),\n    Plot.graticule(),\n    Plot.geo(ocean, {fill: ocean_color, opacity: 0.7}),\n    Plot.geo(land, {fill: land_color}),\n    Plot.line(df, {\n      x: \"longitude\", y: \"latitude\", z: \"segment_id\",\n      r: 0.7, stroke: \"grey\", strokeOpacity: 0.7,\n    }),\n    Plot.tip(df, Plot.pointer({\n      x: \"longitude\", y: \"latitude\", title: (d) =&gt; d.segment_id,\n      format: (d) =&gt; `${d}`, textPadding: 4,\n    }))\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof longitude = Inputs.range([-180, 180], {label: \"Longitude\", step: 1, value: -30})\nviewof latitude = Inputs.range([-90, 90], {label: \"Latitude\", step: 1, value: 0})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nd_found = sf.length &gt; 0\n// display error is no matches\nd_found ? html`&lt;div&gt;&lt;/div&gt;` : html`&lt;p class=\"filter-error\"&gt;&lt;i class=\"bi bi-exclamation-triangle\"&gt;&lt;/i&gt; No segments match selected filters&lt;/p&gt;`\ndg = d3.group(df, d =&gt; d.segment_id)\n// selector for individual segment\nviewof ds = Inputs.select(dg, {\n  value: dg.get(112), // default segment\n  format: ([k, v]) =&gt; `Segment ${k} (Flight ${v[0].flight_id})`\n})\n\nasync function getSegment(seg_id) {\n  const rows = await redivis\n    .user('SDSS')\n    .dataset('project_loon')\n    .query(`\n       SELECT *\n       FROM loon\n       WHERE segment_id = ${seg_id}\n    `)\n    .listRows()\n  return rows;\n}\n\nviewof download_button_segment = {\n  let button = Inputs.button(\"Download segment\");\n  button.addEventListener(\"click\", async function () {\n    const df_full = await getSegment(ds[0].segment_id);\n    download(\"project_loon_filtered.csv\", convertToCSV(df_full));\n  });\n  return button;\n}\n\nd_found ? html`&lt;div class=\"segment-buttons\"&gt;${viewof ds} ${viewof download_button_segment}&lt;/div&gt;` : html`&lt;div&gt;&lt;/div&gt;`\nstart_color = \"var(--bs-success)\"\nend_color = \"var(--bs-danger)\"\n\n// function for how to format data on map\nprint_date = d =&gt; d.toISOString().split('T')[0]\n\n// map -- whole world equirectangular\nd_found ? Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  projection: { type: \"equirectangular\" },\n  marks: [\n    Plot.frame(),\n    Plot.graticule(),\n    Plot.geo(ocean, {fill: ocean_color, opacity: 0.7}),\n    Plot.geo(land, {fill: land_color}),\n    // trajectory path\n    Plot.line(ds, {\n      x: \"longitude\", y: \"latitude\",\n      r: 1, stroke: \"black\", strokeOpacity: 0.3,\n    }),\n    // start marker\n    Plot.dot(ds.slice(0, 1), {\n      x: \"longitude\", y: \"latitude\",\n      r: 3, fill: start_color, symbol: \"triangle\"\n    }),\n    // start date text\n    Plot.text(ds.slice(0, 1), {\n      x: \"longitude\", y: \"latitude\",\n      text: d =&gt; print_date(d.time), dy: -7, lineAnchor: \"bottom\", fontSize: 14\n    }),\n    // end marker\n    Plot.dot(ds.slice(ds.length - 1, ds.length), {\n      x: \"longitude\", y: \"latitude\",\n      r: 3, fill: end_color, symbol: \"square\"\n    }),\n    // end date text\n    Plot.text(ds.slice(ds.length - 1, ds.length), {\n      x: \"longitude\", y: \"latitude\",\n      text: d =&gt; print_date(d.time), dy: -7, lineAnchor: \"bottom\", fontSize: 14\n    })\n  ],\n}) : html`&lt;div&gt;&lt;/div&gt;`\nget_circle = (seg) =&gt; {\n  // find min and max longitude and latitude\n  const minLon = d3.min(seg.map(d =&gt; d.longitude))\n  const maxLon = d3.max(seg.map(d =&gt; d.longitude))\n  const minLat = d3.min(seg.map(d =&gt; d.latitude))\n  const maxLat = d3.max(seg.map(d =&gt; d.latitude))\n  // define rectangle with min/max long/lat corners\n  const corners = [[minLon, minLat], [minLon, maxLat], [maxLon, minLat], [maxLon, maxLat]]\n  // find rectangle's center\n  const center = [(minLon + maxLon) / 2, (minLat + maxLat) / 2]\n  // find max of geo distances from each corner to center\n  const dist = d3.max(corners, corner =&gt; d3.geoDistance(center, corner))\n  // turn geo distance into radius\n  const radius = dist * (180 / Math.PI)\n  // define geo circle with computed center and radius\n  const circle = d3.geoCircle().center(center).radius(radius)()\n  return circle\n}\n\n// find above circle\ncircle = d_found ? get_circle(ds) : null\n\n// map -- zoomed in azimuthal\nd_found ? Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  projection: { type: \"azimuthal-equidistant\", domain: circle },\n  marks: [\n    Plot.frame(),\n    Plot.graticule(),\n    Plot.geo(ocean, {fill: ocean_color, opacity: 0.7}),\n    Plot.geo(land, {fill: land_color}),\n    // trajectory path\n    Plot.line(ds, {\n      x: \"longitude\", y: \"latitude\",\n      r: 1, stroke: \"black\", strokeOpacity: 0.3,\n    }),\n    // start marker\n    Plot.dot(ds.slice(0, 1), {\n      x: \"longitude\", y: \"latitude\",\n      r: 6, fill: start_color, symbol: \"triangle\"\n    }),\n    // start date text\n    Plot.text(ds.slice(0, 1), {\n      x: \"longitude\", y: \"latitude\",\n      text: d =&gt; print_date(d.time), dy: -8, lineAnchor: \"bottom\", fontSize: 14\n    }),\n    // end marker\n    Plot.dot(ds.slice(ds.length - 1, ds.length), {\n      x: \"longitude\", y: \"latitude\",\n      r: 6, fill: end_color, symbol: \"square\"\n    }),\n    // end date text\n    Plot.text(ds.slice(ds.length - 1, ds.length), {\n      x: \"longitude\", y: \"latitude\",\n      text: d =&gt; print_date(d.time), dy: -8, lineAnchor: \"bottom\", fontSize: 14\n    })\n  ],\n}) : html`&lt;div&gt;&lt;/div&gt;`\nviewof scatter_altitude = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  width: 900,\n  height: 200,\n  inset: 8,\n  grid: true,\n  y: { label: \"Altitude (meters)\" },\n  marks: [\n    Plot.frame(),\n    Plot.dot(ds, { x: \"time\", y: \"altitude\", r: 0.5 }),\n  ]\n})\n\nd_found ? html`\n  &lt;form&gt;&lt;label&gt;Altitude&lt;/label&gt;&lt;/form&gt;\n  ${viewof scatter_altitude}\n` : html`&lt;div&gt;&lt;/div&gt;`\nwinds = new Map([[\"Zonal (east-west)\", \"wind_u\"],\n                 [\"Meridional (north-south)\", \"wind_v\"]])\nviewof y_wind = Inputs.select(winds, {label: \"Wind\"})\n\nviewof scatter_wind = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  width: 900,\n  height: 200,\n  inset: 8,\n  grid: true,\n  y: { label: \"Velocity (meters/second)\" },\n  marks: [\n    Plot.frame(),\n    Plot.dot(ds, { x: \"time\", y: y_wind, r: 0.5 }),\n  ]\n})\n\nd_found ? html`\n  ${viewof y_wind}\n  ${viewof scatter_wind}\n` : html`&lt;div&gt;&lt;/div&gt;`\nfluxes = new Map([[\"Total\", \"flux_total\"],\n                  [\"Eastward\", \"flux_east\"],\n                  [\"Westward\", \"flux_west\"],\n                  [\"Northward\", \"flux_north\"],\n                  [\"Southward\", \"flux_south\"]])\nviewof y_flux = Inputs.select(fluxes, {label: \"Flux\"})\n\nviewof scatter_flux = Plot.plot({\n  style: { fontFamily: \"var(--sans-serif)\" },\n  width: 900,\n  height: 200,\n  inset: 8,\n  grid: true,\n//  y: { label: \"Flux (millipascals)\", transform: (f) =&gt; Math.abs(f * 1000) },\n  y: { label: \"Flux (log mPa)\", transform: (f) =&gt; Math.log(Math.abs(f * 1000)) },\n  marks: [\n    Plot.frame(),\n    Plot.dot(ds, { x: \"time\", y: y_flux, r: 0.5 }),\n  ]\n})\n\nd_found ? html`\n  ${viewof y_flux}\n  ${viewof scatter_flux}\n` : html`&lt;div&gt;&lt;/div&gt;`\n// data table for selected segment's data\nd_found ? Inputs.table(ds) : html`&lt;div&gt;&lt;/div&gt;`"
  },
  {
    "objectID": "analysis.html",
    "href": "analysis.html",
    "title": "Project Loon",
    "section": "",
    "text": "You can access the project_loon data programmatically using the Redivis API for R or Python.\n\nRPython\n\n\n\nInstall the redivis-r package:\n\ndevtools::install_github(\"redivis/redivis-r\")\n\nGenerate and set an API token.\nAccess the data:\n\nlibrary(redivis)\n\nuser &lt;- redivis::user(\"sdss\")\ndataset &lt;- user$dataset(\"project_loon\")\ntable &lt;- dataset$table(\"loon\")\n\n# Load table as tidyverse tibble\ndf &lt;- table$to_tibble()\nView documentation\n\n\n\nInstall the redivis-python client library:\n\npip install --upgrade redivis\n\nGenerate and set an API token.\nAccess the data:\n\nimport redivis\n\nuser = redivis.user(\"sdss\")\ndataset = user.dataset(\"project_loon\")\ntable = dataset.table(\"loon\")\n\n# Load table as a dataframe\ndf = table.to_pandas_dataframe()\nView documentation"
  },
  {
    "objectID": "analysis.html#programmatic-access",
    "href": "analysis.html#programmatic-access",
    "title": "Project Loon",
    "section": "",
    "text": "You can access the project_loon data programmatically using the Redivis API for R or Python.\n\nRPython\n\n\n\nInstall the redivis-r package:\n\ndevtools::install_github(\"redivis/redivis-r\")\n\nGenerate and set an API token.\nAccess the data:\n\nlibrary(redivis)\n\nuser &lt;- redivis::user(\"sdss\")\ndataset &lt;- user$dataset(\"project_loon\")\ntable &lt;- dataset$table(\"loon\")\n\n# Load table as tidyverse tibble\ndf &lt;- table$to_tibble()\nView documentation\n\n\n\nInstall the redivis-python client library:\n\npip install --upgrade redivis\n\nGenerate and set an API token.\nAccess the data:\n\nimport redivis\n\nuser = redivis.user(\"sdss\")\ndataset = user.dataset(\"project_loon\")\ntable = dataset.table(\"loon\")\n\n# Load table as a dataframe\ndf = table.to_pandas_dataframe()\nView documentation"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Project Loon",
    "section": "",
    "text": "The purpose of this dataset is to offer an estimate of the horizontal momentum fluxed vertically by the atmospheric internal gravity waves (GWs) observed by Project Loon balloons. This vertical flux of horizontal momentum is commonly referred to as the GW momentum flux. Before estimating the GW momentum fluxes, additional processing was necessary to remove data sampling errors, irregularities, and balloon maneuvering.\n\n\n\nThe procedures for this processing, and the subsequent analysis of the processed data, are described in Green et al. (2024). The Python code (in Jupyter notebooks) that was used for both is available at: https://github.com/DataWaveProject/Loon-momentum-fluxes.\n\n\n\nSee the following sample project for examples: https://redivis.com/projects/q08b-889vc3xgg."
  },
  {
    "objectID": "about.html#project-loon",
    "href": "about.html#project-loon",
    "title": "Project Loon",
    "section": "",
    "text": "The purpose of this dataset is to offer an estimate of the horizontal momentum fluxed vertically by the atmospheric internal gravity waves (GWs) observed by Project Loon balloons. This vertical flux of horizontal momentum is commonly referred to as the GW momentum flux. Before estimating the GW momentum fluxes, additional processing was necessary to remove data sampling errors, irregularities, and balloon maneuvering.\n\n\n\nThe procedures for this processing, and the subsequent analysis of the processed data, are described in Green et al. (2024). The Python code (in Jupyter notebooks) that was used for both is available at: https://github.com/DataWaveProject/Loon-momentum-fluxes.\n\n\n\nSee the following sample project for examples: https://redivis.com/projects/q08b-889vc3xgg."
  }
]